class SearchEngine
types
-- TODO Define types here
								 
values
-- TODO Define values here
instance variables

	protected transportMap: TransportGraph;
	protected trips: seq of Trip := [];
	protected settledNodes: set of Station := {};
	protected unsettledNodes: set of Station := {};
	protected distances: map Station to real := {|->};
	protected prev: map Station to Station := {|->}
	
		
operations

	public SearchEngine: TransportGraph * seq of Trip ==> SearchEngine
	SearchEngine(graph, t) ==
	(
		transportMap := graph;
		trips := t;
		return self;
	);
	
	private removeHighestValue: seq of Station ==> seq of Station
	removeHighestValue(heap) == 
	(
		dcl max : nat := 1;
		dcl index : nat := 1;
		dcl finalHeap : seq of Station := [];
		
		while( index < len heap ) do (
			
			dcl heapMax : Station := heap(max);
			dcl heapCurr : Station := heap(index);
			
			if(heapCurr.weigth > heapMax.weigth) then (
				max := index;
			);
			
			index := index + 1;
			
		);
		
		index := 1;
		
		while(index < len heap) do (
			dcl heapCurr : Station := heap(index);
			if(index <> max) then finalHeap := finalHeap ^ [heapCurr];
		);
		
		return finalHeap;
	);
	
	private getLowestDistanceNode: set of Station ==> Station
	getLowestDistanceNode(unsettledNodes) == 
	(
		dcl node : Station;
		dcl lowestDist : real := 100000;
		
		for all n in set unsettledNodes do (
			
			dcl weigth : real := n.weigth;
			
			if(weigth < lowestDist) then (
				lowestDist := weigth;
				node := n;
			);
			
		);
		
		return node;
	);
	
	/*
	private remove : set of Utilities`Station * Utilities`Station ==> set of Utilities`Station
	remove(unsettledNodes, node) == 
	(
		dcl newUnsettledNodes : set of Utilities`Station;
		
		for all n in set unsettledNodes do (
			if(stringEqual(n.name, node.name) = false) then (
				newUnsettledNodes := newUnsettledNodes union {n};
			);
		);
		
		return newUnsettledNodes;
	);*/
	
	-- print s.getPathsDist(['P','o','r','t','o'],['F','a','r','o'])
	public disjkstraAlgorithm: Utilities`String ==> ()
	disjkstraAlgorithm(origin) ==
	(
		dcl station : Station := transportMap.getStation(origin);
		
		distances := distances ++ {station |-> 0};
		-- prev := prev ++ {station |-> station};
		unsettledNodes := unsettledNodes union {station};
		
		while(unsettledNodes <> {}) do (
		
			dcl minimumNode : Station := getMinimumNode();
			settledNodes := settledNodes union {minimumNode};
			unsettledNodes := unsettledNodes\{minimumNode};
			
			findMinimalDistances(minimumNode);
		
		);
	);
	
	private findMinimalDistances: Station ==> () 
	findMinimalDistances(node) ==
	(
		dcl adjacentNodes: set of Station := transportMap.getNeighborsOfNode(node.name);
		
		for all target in set adjacentNodes do (
					
			if(getShortestDistance(target) > getShortestDistance(node) + getDistance(node, target)) then (
				
				distances := distances ++ {target |-> getShortestDistance(node) + getDistance(node, target)};
				prev := prev ++ {target |-> node};
				
				unsettledNodes := unsettledNodes union {target}; 
			)
		);
	);
	
	private getMinimumNode: () ==> Station 
	getMinimumNode() == 
	(
		dcl minimum : Station := new Station("",false,0);
		for all n in set unsettledNodes do (
			if(minimum.name = "") then (
				minimum := n;
			)
			else (
				if(getShortestDistance(n) < getShortestDistance(minimum)) then (
					minimum := n;
				); 
			);
		);
		
		return minimum;
	);
	
	private getShortestDistance: Station ==> real 
	getShortestDistance(destination) == 
	(
		dcl d: map Station to real := {destination} <: distances;
		dcl d1 : set of real := rng d;
		dcl dist : real := getFirstFromSet(d1);
		
		return dist;
	);
	
	private getDistance: Station * Station ==> real
	getDistance(node, target) ==
	(
		for all con in set transportMap.listConnections() do (
			
			if(stringEqual(con.source.name,node.name) and stringEqual(con.destination.name, target.name)) then (
				-- change this later to anything we like
				return con.distance;
			);
			
		);
		
		return 0;
	);
	
	private getFirstFromSet: set of real ==> real
	getFirstFromSet(reals) == 
	(
		if(reals <> {}) then (
			for all ds in set reals do return ds;
		)
		else return 1000000;
	);
	
	private stringEqual: Utilities`String * Utilities`String ==> bool
	stringEqual(s1, s2) ==
	(
	 if len s1 <> len s2 then
	 	return false;
	 for idx = 1 to len s1 do
	 	if s1(idx) <> s2(idx) then return false;
	 
	 return true;
	);
	
	/** 
	* Returns seq of nodes from origin to destination
	**/
	public getPath: Utilities`String ==> seq of Station
	getPath(destination) ==
	(	
		dcl path : seq of Station := [];
		dcl revertedPath: seq of Station := [];
		dcl stationDest : Station := transportMap.getStation(destination);
		/*dcl tmp : map Station to Station := {stationDest} <: prev;
		dcl tmp2 : set of Station := rng tmp;
		
		if (tmp2 = {}) then (
			return [];
		);*/
		
		path := path ^ [stationDest];
		
		while (prev(stationDest) <> undefined) do (
			
			stationDest := prev(stationDest);
			path := path ^ [stationDest];
			
		);
		
		revertedPath := revertSeq(path);
		
		return revertedPath;
	);
	
	private revertSeq: seq of Station ==> seq of Station
	revertSeq(stations) ==
	(
		-- end this
		return stations;
	);
	
	/*
		create t := new TransportGraph()
		create s := new SearchEngine(t, [])
		print s.disjkstraAlgorithm(['P','o','r','t','o'])
		print s.getPath(['M','a','d','r','i','d'])
	*/
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end SearchEngine