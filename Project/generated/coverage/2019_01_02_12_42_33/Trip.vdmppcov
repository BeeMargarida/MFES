class Trip
types
-- TODO Define types here
	public Segment :: startCity : Utilities`String
								 		--destinationCity : Utilities`String
								 		timeDuration: real
								 		distance: real
								 		price: real
								 		meanOfTransport: Connection`Type;
values
-- TODO Define values here
instance variables

	protected segments : seq of Segment;
	protected finalResults : seq of real;
	
operations
	
	-- constructor
	public Trip: seq of Segment ==> Trip
	Trip(segs) ==
	(
		segments := segs;
		finalResults := [];
		return self;
	)
	post segments = segs and finalResults = [];
	
	-- add new segment
	public addSegment: Utilities`String * seq of real * Connection`Type ==> ()
	addSegment(origin, distValues, meanType) ==
	(
		dcl segment : Segment := mk_Segment(origin, distValues(3), distValues(1), distValues(2), meanType);
		segments := segments ^[segment]; 
	);
	
	-- add new segment withouy mean of transportation info
	public addSegmentFirst: Utilities`String * seq of real ==> ()
	addSegmentFirst(origin, distValues) ==
	(
		dcl segment : Segment := mk_Segment(origin, distValues(3), distValues(1), distValues(2), <NONE>);
		segments := segments ^[segment]; 
	);
	
	-- get segments
	public getSegments: () ==> seq of Segment
	getSegments() ==
	(
		return segments;
	);
	
	-- set final results
	public setFinalResults : seq of real ==> ()
	setFinalResults(results) ==
	(
		finalResults := results;
	)
<<<<<<< HEAD
	post finalResults = results;   
=======
	post finalResults = results;
>>>>>>> 815d3a5ca15d53af507152d1c63d183532845df3

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Trip